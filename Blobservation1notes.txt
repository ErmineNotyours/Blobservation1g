0
[ [ 0, 0, 2, 0, 0, 0, 0, 3 ],
  [ 0, 0, 0, 0, 0, 0, 0, 0 ],
  [ 0, 0, 0, 0, 0, 0, 0, 1 ],
  [ 0, 0, 0, 0, 4, 0, 0, 0 ],
  [ 3, 0, 0, 0, 0, 0, 0, 0 ],
  [ 0, 0, 0, 0, 0, 0, 0, 0 ],
  [ 0, 0, 0, 0, 0, 2, 0, 0 ], <-- 2 should merge with 1 for 3
  [ 5, 0, 0, 2, 0, 0, 1, 0 ] ]
final
[ [ 0, 0, 0, 0, 0, 0, 0, 0 ],
  [ 0, 0, 0, 2, 0, 0, 0, 3 ],
  [ 0, 0, 0, 0, 0, 4, 0, 1 ],
  [ 0, 0, 0, 0, 0, 0, 0, 0 ],
  [ 0, 0, 0, 0, 0, 0, 0, 0 ],
  [ 0, 3, 0, 0, 0, 0, 0, 0 ],
  [ 5, 0, 0, 0, 0, 0, 0, 0 ],
  [ 0, 0, 0, 0, 2, 0, 1, 0 ] ]

Expected:    [[0, 6, 5], [1, 5, 3], [3, 1, 2], [4, 7, 2], [5, 2, 4], [6, 7, 3], [7, 1, 3], [7, 2, 1]],
instead got: [[1, 5, 3], [1, 7, 5], [3, 1, 2], [4, 7, 2], [5, 4, 4], [6, 7, 1], [7, 1, 3], [7, 2, 1]]

Exp [0, 6, 5] needs to switch places with actual [1, 5, 3], otherwise works.  The 5 needed to move up to the 3, not right to the 2.  This right bias may be the cause of right movement off the board.

Before angle sort { candidates: 
   [ { distance: 3, y2: 4, x2: 0, angle: 180 },
     { distance: 3, y2: 7, x2: 3, angle: 90 },

After angle sort { candidates: 
   [ { distance: 3, y2: 7, x2: 3, angle: 90 },
     { distance: 3, y2: 4, x2: 0, angle: 180 },

Should have been 0 vs 90.  the 0, 4 is straight up. 0, 7 to 0, 4 produce 90 deg.  Rotate to 180
Math.atan2((y1 - candidates[k].y2), (candidates[k].x2 - x1))
Math.atan2((7 - 4), (0 - 0))
Math.atan2(3, 0) = 1.57rad = 90 deg

Switch the order of the y subtraction and get (same thing)
Expected:    [[0, 6, 5], [1, 5, 3], [3, 1, 2], [4, 7, 2], [5, 2, 4], [6, 7, 3], [7, 1, 3], [7, 2, 1]], instead got: [[1, 5, 3], [1, 7, 5], [3, 1, 2], [4, 7, 2], [5, 4, 4], [6, 7, 1], [7, 1, 3], [7, 2, 1]]

Take out Math.abs							    v 
Expected:    [[0, 6, 5], [1, 5, 3], [3, 1, 2], [4, 7, 2], [5, 2, 4], [6, 7, 3], [7, 1, 3], [7, 2, 1]], instead got: [[0, 6, 5], [1, 5, 3], [3, 1, 2], [4, 7, 2], [5, 2, 4], [6, 7, 1], [7, 1, 3], [7, 2, 1]]

Fixed!

first  0  1  2  3  4  5  6  7
   [ [ 0, 0, 0, 0, 0, 0, 0, 0 ], 0
     [ 0, 0, 0, 2, 0, 0, 0, 3 ], 1
     [ 0, 0, 0, 0, 0, 4, 0, 1 ], 2
     [ 0, 0, 0, 0, 0, 0, 0, 0 ], 3
     [ 0, 0, 0, 0, 0, 0, 0, 0 ], 4
     [ 0, 3, 0, 0, 0, 0, 0, 0 ], 5
     [ 5, 0, 0, 0, 0, 0, 0, 0 ], 6
     [ 0, 0, 0, 0, 2, 0, 3, 0 ] ]7
1
   [ [ 0, 0, 0, 0, 0, 0, 0, 0 ],
     [ 0, 0, 0, 0, 0, 0, 0, 0 ], <-- expected 4 to move towards 3 because 3 is bigger?
     [ 0, 0, 0, 0, 2, 0, 4, 4 ],     (3 is further away)
     [ 0, 0, 0, 0, 0, 0, 0, 0 ], A: diagonals count as 1 distance.  Idea: go to each of the
     [ 0, 0, 0, 0, 0, 0, 0, 0 ], 8 bordering cells and test for size and distance there.
     [ 0, 5, 0, 0, 0, 0, 0, 0 ],
     [ 0, 0, 3, 0, 0, 2, 0, 0 ],
     [ 0, 0, 0, 0, 0, 3, 0, 0 ] ] }					 v
Expected:    [[1, 5, 5], [2, 6, 3], [4, 2, 2], [5, 6, 2], [5, 7, 3], [6, 1, 4], [7, 2, 4]],
instead got: [[1, 5, 5], [2, 6, 3], [4, 2, 2], [5, 6, 2], [5, 7, 3], [6, 2, 4], [7, 2, 4]]

Before assignment { x1: 5,
  y1: 2,
  x2: 1,
  y2: 5,
  candidates: 
   [ { distance: 2.23606797749979, y2: 1, x2: 3 },
     { distance: 2.23606797749979, y2: 1, x2: 7 }, <-- This is the one the test wanted us to pick
     { distance: 2, y2: 2, x2: 7 } ] } <-- This is the lower distance value picked
maybe try a simpler approach where you count x & y distances

Moving on,
{ h: 8, w: 10 }
{ generation0: 
   [ { x: 3, y: 6, size: 3 },
     { x: 8, y: 0, size: 2 },
     { x: 5, y: 3, size: 6 },
     { x: 1, y: 1, size: 1 },
     { x: 2, y: 6, size: 2 },
     { x: 1, y: 5, size: 4 },
     { x: 7, y: 7, size: 1 },
     { x: 9, y: 6, size: 3 },
     { x: 8, y: 3, size: 4 },
     { x: 5, y: 6, size: 3 },
     { x: 0, y: 6, size: 1 },
     { x: 3, y: 2, size: 5 } ] }
{ blobs: 
   [ [ 0, 0, 0, 0, 0, 0, 0, 0, 2, 0 ],
     [ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ],
     [ 0, 0, 0, 5, 0, 0, 0, 0, 0, 0 ], 
     [ 0, 0, 0, 0, 0, 6, 0, 0, 4, 0 ], 
     [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], 
     [ 0, 4, 0, 0, 0, 0, 0, 0, 0, 0 ],
     [ 1, 0, 2, 3, 0, 3, 0, 0, 0, 3 ],
     [ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 ],
First tested non-square grid.
1 move
after negative patch:
   [ [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
     [ 0, 1, 5, 0, 0, 0, 0, 2, 0, 0 ],
     [ 0, 0, 0, 0, 6, 0, 0, 0, 0, 0 ], Possible percision error with wide diagonal weighting?
     [ 0, 0, 0, 0, 0, 0, 0, 4, 0, 0 ], 
     [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], 
     [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
     [ 1, 2, 7, 0, 0, 0, 0, 0, 0, 0 ],
     [ 0, 0, 0, 0, 0, 0, 3, 1, 3, 0 ] ] }

Expected:    [[0, 6, 1], [1, 1, 1], [1, 6, 2], [2, 1, 5], [2, 6, 7], [4, 2, 6], [6, 7, 3], [7, 1, 2], [7, 4, 4], [7, 7, 1], [8, 7, 3]],
instead got: [[0, 6, 1], [1, 1, 1], [1, 6, 2], [2, 1, 5], [2, 6, 7], [4, 2, 6], [6, 7, 3], [7, 1, 2], [7, 3, 4], [7, 7, 1], [8, 7, 3]]
    ^
{ k: 0, angle: -90 }
{ distance: 3, y2: 0, x2: 8, angle: 270 }

   [ [ 0, 0, 0, 0, 0, 0, 0, 0, 2, 0 ],
     [ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ],
     [ 0, 0, 0, 5, 0, 0, 0, 0, 0, 0 ], 
     [ 0, 0, 0, 0, 0, 6, 0, 0, 4, 0 ],  <-- 4 orig position
     [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], 
     [ 0, 4, 0, 0, 0, 0, 0, 0, 0, 0 ],
     [ 1, 0, 2, 3, 0, 3, 0, 0, 0, 3 ],
     [ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 ],
Final { blobs: 
   [ [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], 
     [ 0, 1, 5, 0, 0, 0, 0, 2, 0, 0 ],
     [ 0, 0, 0, 0, 6, 0, 0, 0, 4, 0 ], <-- 4 moved up to 8, 2 to move toward the 2 (makes sense)
     [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], 
     [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], <-- 4 should move down left to 7, 4 per test.
     [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
     [ 1, 2, 7, 0, 0, 0, 0, 0, 0, 0 ],
     [ 0, 0, 0, 0, 0, 0, 3, 1, 3, 0 ] ] }
Expected:    [[0, 6, 1], [1, 1, 1], [1, 6, 2], [2, 1, 5], [2, 6, 7], [4, 2, 6], [6, 7, 3], [7, 1, 2], [7, 4, 4], [7, 7, 1], [8, 7, 3]],
instead got: [[0, 6, 1], [1, 1, 1], [1, 6, 2], [2, 1, 5], [2, 6, 7], [4, 2, 6], [6, 7, 3], [7, 1, 2], [7, 7, 1], [8, 2, 4], [8, 7, 3]]
    	    ^  ^  ^